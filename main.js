/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => JotsPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian10 = require("obsidian");

// src/settings.ts
var import_obsidian6 = require("obsidian");

// src/settings/sections/GeneralSection.ts
var import_obsidian = require("obsidian");

// src/constants.ts
var DEFAULT_SETTINGS = {
  sectionName: "JOTS",
  rules: [{
    name: "Default JOTS Header",
    enabled: true,
    type: "folder" /* Folder */,
    path: "",
    // Matches all files
    recursive: true,
    contentSource: "text" /* Text */,
    footerText: "## JOTS\n",
    renderLocation: "header" /* Header */
  }, {
    name: "Default JOTS Footer",
    enabled: true,
    type: "folder" /* Folder */,
    path: "",
    // Matches all files
    recursive: true,
    contentSource: "text" /* Text */,
    footerText: "---\nManaged by JOTS",
    renderLocation: "footer" /* Footer */
  }],
  refreshOnFileOpen: false,
  sectionIcon: `<svg enable-background="new 0 0 512 512" version="1.1" viewBox="0 0 512 512" xml:space="preserve" xmlns="http://www.w3.org/2000/svg">
<path d="m305.93 418.92c-26.828 38.057-63.403 55.538-109.44 55.029-46.309-0.51208-92.629-0.10562-138.94-0.1196-13.622-0.004119-24.352-9.1858-25.925-22.11-1.829-15.037 6.0142-27.026 19.865-30.147 2.2417-0.50519 4.6213-0.54819 6.9375-0.5509 29.488-0.034637 58.979 0.23877 88.464-0.090301 35.371-0.39474 62.735-15.755 79.889-46.723 44.762-80.809 88.894-161.97 133.28-242.98 0.86243-1.5741 1.7962-3.1091 2.8304-4.8929 20.175 28.278 45.373 45.663 82.159 40.199-2.4802 4.5968-4.9266 9.2147-7.4479 13.791-43.214 78.443-86.436 156.88-129.66 235.32-0.56052 1.017-1.2266 1.9758-2.0111 3.2818z" fill="#000"/>
<path d="m31.481 206.92c0.12606-16.992 10.285-27.084 26.844-27.085 45.311-0.002991 90.626 0.34482 135.93-0.18555 16.216-0.18983 27.237 12.775 27.018 25.768-0.27806 16.481-10.372 27.253-27.004 27.386-19.656 0.15742-39.314 0.037079-58.971 0.037094-25.487 0-50.975 0.076645-76.462-0.027741-16.297-0.066757-26.574-9.7617-27.356-25.893z" fill="#000"/>
<path d="m45.057 61.868c4.3536-1.0541 8.3563-2.7336 12.366-2.7499 45.821-0.18574 91.644-0.13414 137.47-0.10933 15.673 0.008488 26.26 10.689 26.279 26.385 0.018921 15.985-10.543 26.596-26.562 26.602-45.322 0.016785-90.645 0.009247-135.97 0.003746-13.104-0.001594-22.883-6.7656-26.238-18.115-3.7646-12.734 0.91893-24.859 12.657-32.016z" fill="#000"/>
<path d="m124 353.17c-22.485 0-44.47 0.016082-66.455-0.005646-15.032-0.014862-25.818-10.368-26.064-24.955-0.27467-16.321 9.6991-27.874 25.236-27.956 46.3-0.24435 92.603-0.21823 138.9-0.015014 15.618 0.068542 25.762 11.459 25.549 27.635-0.19647 14.927-10.908 25.281-26.218 25.292-23.484 0.016968-46.968 0.004456-70.952 0.004456z" fill="#000"/>
<path d="m455.85 44.05c18.602 9.608 28.421 26.609 26.551 45.493-1.8979 19.171-14.44 34.297-32.867 39.638-18.386 5.3289-38.272-1.6027-49.417-17.225-11.283-15.816-11.208-37.314 0.18686-53.211 11.052-15.418 31.363-22.339 49.579-16.858 1.9016 0.5722 3.742 1.3482 5.967 2.1632z" fill="#000"/>
</svg>`,
  sectionFormat: "Plain",
  labelColor: "#000000",
  taskLetters: ["A", "B", "C"],
  journalRootFolder: "Journals",
  journalFolderPattern: "YYYY/YYYY-MM",
  journalFilePattern: "YYYY-MM-DD_ddd",
  personalAccessToken: "",
  updateAtStartup: true
};

// src/settings/sections/AppearanceSection.ts
var import_obsidian2 = require("obsidian");

// src/settings/sections/JournalSection.ts
var import_obsidian3 = require("obsidian");

// src/settings/sections/HeadersFootersSection.ts
var import_obsidian5 = require("obsidian");

// src/utils/MultiSuggest.ts
var import_obsidian4 = require("obsidian");

// src/utils.ts
function svgToDataUri(svgData) {
  try {
    let cleanedSvg = svgData.replace(/\s+/g, " ").trim();
    if (cleanedSvg.includes("SVGRepo")) {
      const iconCarrierMatch = cleanedSvg.match(/<g id="SVGRepo_iconCarrier">(.*?)<\/g>/);
      if (iconCarrierMatch) {
        cleanedSvg = iconCarrierMatch[1].trim();
        cleanedSvg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">${cleanedSvg}</svg>`;
      }
    }
    cleanedSvg = cleanedSvg.replace(/fill="#[0-9A-Fa-f]{3,6}"/g, 'fill="currentColor"').replace(/fill="black"/g, 'fill="currentColor"').replace(/fill="none"/g, "").replace(/fill="white"/g, 'fill="currentColor"');
    const encodedSvg = encodeURIComponent(cleanedSvg).replace(/'/g, "%27").replace(/"/g, "%22");
    return `data:image/svg+xml,${encodedSvg}`;
  } catch (error) {
    console.error("SVG processing error:", error, "\nOriginal SVG:", svgData);
    throw error;
  }
}
function generateJotsIconCss(sectionName, svgData, labelColor) {
  const dataUri = svgToDataUri(svgData);
  return `.callout[data-callout="${sectionName.toLowerCase()}"] {
    --callout-color: ${labelColor};
    --callout-title-color: ${labelColor};
    margin: 0;
    padding: 0;
    position: relative;
}
.callout[data-callout="${sectionName.toLowerCase()}"] > .callout-title {
    color: ${labelColor};
    margin: 0;
    padding: 0;
}
.callout[data-callout="${sectionName.toLowerCase()}"] > .callout-title > .callout-title-inner {
    color: ${labelColor};
}
.callout[data-callout="${sectionName.toLowerCase()}"] > .callout-content {
    margin: 0;
    padding: 0 0 0 1em;
    position: relative;
}
.callout[data-callout="${sectionName.toLowerCase()}"] .callout-content blockquote {
    margin: 0;
    padding: 0;
    border: none;
}
.callout[data-callout="${sectionName.toLowerCase()}"] > .callout-title > .callout-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 17px;
    height: 17px;
}
.callout[data-callout="${sectionName.toLowerCase()}"] > .callout-title > .callout-icon > svg {
    mask-image: url("${dataUri}");
    -webkit-mask-image: url("${dataUri}");
    mask-repeat: no-repeat;
    -webkit-mask-repeat: no-repeat;
    mask-size: contain;
    -webkit-mask-size: contain;
    mask-position: center;
    -webkit-mask-position: center;
    background-color: currentColor;
    width: 100%;
    height: 100%;
}`;
}

// src/plugin-manager.ts
var import_obsidian7 = require("obsidian");
var PluginManager = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  scrubRepositoryUrl(address) {
    let scrubbedAddress = address.replace(/https?:\/\/github\.com\//i, "");
    scrubbedAddress = scrubbedAddress.replace(/\.git$/i, "");
    scrubbedAddress = scrubbedAddress.replace(/\/$/, "");
    return scrubbedAddress.trim();
  }
  async addPlugin(repositoryPath) {
    try {
      const scrubbedPath = this.scrubRepositoryUrl(repositoryPath);
      const manifest = await this.validateRepository(scrubbedPath);
      if (!manifest) {
        return false;
      }
      const currentVersion = await this.getInstalledVersion(manifest.id);
      const comparison = this.compareVersions(currentVersion, manifest.version);
      if (currentVersion && comparison >= 0) {
        console.log(`Plugin ${manifest.name} is up to date (${currentVersion})`);
        return false;
      }
      const releaseFiles = await this.getReleaseFiles(scrubbedPath, manifest);
      if (!releaseFiles) {
        return false;
      }
      await this.writePluginFiles(manifest.id, releaseFiles);
      await this.enablePlugin(manifest.id);
      if (currentVersion) {
        console.log(`Updated plugin ${manifest.name} from ${currentVersion} to ${manifest.version}`);
      } else {
        new import_obsidian7.Notice(`Plugin ${manifest.name} has been installed`);
      }
      return true;
    } catch (error) {
      console.error("Error installing plugin:", error);
      new import_obsidian7.Notice(`Failed to install plugin: ${error.message}`);
      return false;
    }
  }
  // Version retrieval methods
  async getInstalledVersion(pluginId) {
    try {
      const app = this.plugin.app;
      const pluginDir = `${app.vault.configDir}/plugins/${pluginId}/`;
      const { adapter } = app.vault;
      if (!await adapter.exists(`${pluginDir}manifest.json`)) {
        return null;
      }
      const manifestContent = await adapter.read(`${pluginDir}manifest.json`);
      const manifest = JSON.parse(manifestContent);
      return manifest.version || null;
    } catch (error) {
      console.error(`Error getting installed version for ${pluginId}:`, error);
      return null;
    }
  }
  async getLatestVersion(repositoryPath) {
    try {
      const headers = {
        "Accept": "application/vnd.github.v3+json",
        "User-Agent": "jots-assistant"
      };
      if (this.plugin.settings.personalAccessToken) {
        headers.Authorization = `token ${this.plugin.settings.personalAccessToken}`;
      }
      try {
        const response = await (0, import_obsidian7.requestUrl)({
          url: `https://raw.githubusercontent.com/${repositoryPath}/master/manifest.json`,
          headers
        });
        if (response.status === 200) {
          try {
            const manifest = JSON.parse(response.text);
            if (manifest.version) {
              return manifest.version;
            }
          } catch (e) {
            console.log("Error parsing master manifest:", e);
          }
        }
      } catch (e) {
        console.log("Error fetching master manifest:", e);
      }
      const release = await this.getRelease(repositoryPath, headers);
      if (release) {
        const manifestContent = await this.fetchReleaseFile(release, "manifest.json", headers);
        if (manifestContent) {
          try {
            const manifest = JSON.parse(manifestContent);
            if (manifest.version) {
              return manifest.version;
            }
          } catch (error) {
            console.error("Error parsing release manifest:", error);
          }
        }
      }
      return null;
    } catch (error) {
      console.error(`Error getting latest version for ${repositoryPath}:`, error);
      return null;
    }
  }
  async validateRepository(repositoryPath) {
    try {
      const headers = {
        "Accept": "application/vnd.github.v3+json",
        "User-Agent": "jots-assistant"
      };
      const release = await this.getRelease(repositoryPath, headers);
      if (!release) {
        return null;
      }
      const manifestContent = await this.fetchReleaseFile(release, "manifest.json", headers);
      if (!manifestContent) {
        new import_obsidian7.Notice("No manifest.json found in release");
        return null;
      }
      let manifest;
      try {
        manifest = JSON.parse(manifestContent);
      } catch (error) {
        new import_obsidian7.Notice("Invalid manifest.json format");
        return null;
      }
      if (!manifest.id || !manifest.version) {
        new import_obsidian7.Notice("Invalid manifest.json (missing id or version)");
        return null;
      }
      return manifest;
    } catch (error) {
      console.error("Error validating repository:", error);
      if (error.status === 403) {
        new import_obsidian7.Notice(
          this.plugin.settings.personalAccessToken ? "GitHub API rate limit exceeded. The personal access token might be invalid." : "GitHub API rate limit exceeded. Try adding a personal access token in settings to increase the limit."
        );
      } else if (error.status === 401) {
        new import_obsidian7.Notice("Invalid GitHub personal access token. Please check your token in settings.");
      }
      return null;
    }
  }
  async getRelease(repositoryPath, headers) {
    try {
      headers = {
        ...headers,
        "Accept": "application/vnd.github.v3+json",
        "User-Agent": "jots-assistant"
      };
      if (this.plugin.settings.personalAccessToken) {
        headers.Authorization = `token ${this.plugin.settings.personalAccessToken}`;
      }
      try {
        await (0, import_obsidian7.requestUrl)({
          url: `https://api.github.com/repos/${repositoryPath}`,
          headers
        });
      } catch (error) {
        if (error.status === 404) {
          return null;
        }
        throw error;
      }
      const apiUrl = `https://api.github.com/repos/${repositoryPath}/releases?per_page=100`;
      const response = await (0, import_obsidian7.requestUrl)({
        url: apiUrl,
        headers
      });
      if (response.text === "404: Not Found") {
        return null;
      }
      let releases;
      try {
        const data = JSON.parse(response.text);
        if (!Array.isArray(data)) {
          console.log("Expected array of releases");
          return null;
        }
        releases = data;
      } catch (e) {
        console.log("Failed to parse releases:", e);
        return null;
      }
      const validReleases = releases.filter(
        (r) => r.assets && Array.isArray(r.assets) && r.assets.length > 0 && r.tag_name && !r.draft && !r.prerelease
      );
      if (validReleases.length === 0) {
        console.log("No valid releases found with assets");
        return null;
      }
      validReleases.sort((a, b) => {
        const aVer = this.coerceSemver(a.tag_name);
        const bVer = this.coerceSemver(b.tag_name);
        if (!aVer || !bVer) {
          return b.tag_name.localeCompare(a.tag_name);
        }
        const aParts = aVer.split(".").map(Number);
        const bParts = bVer.split(".").map(Number);
        for (let i = 0; i < 3; i++) {
          if (bParts[i] > aParts[i])
            return 1;
          if (bParts[i] < aParts[i])
            return -1;
        }
        return 0;
      });
      return validReleases[0];
    } catch (error) {
      console.error("Error fetching release:", error);
      if (error.status === 403) {
        throw new Error("GitHub API rate limit exceeded. Try adding a personal access token in settings.");
      }
      throw error;
    }
  }
  coerceSemver(version) {
    const cleaned = version.replace(/^v/i, "");
    const semverRegex = /^(\d+)\.(\d+)\.(\d+)(?:-[\w.-]+)?(?:\+[\w.-]+)?$/;
    const match = cleaned.match(semverRegex);
    if (match) {
      return `${match[1]}.${match[2]}.${match[3]}`;
    }
    const numbers = cleaned.match(/\d+/g);
    if (numbers && numbers.length >= 3) {
      return `${numbers[0]}.${numbers[1]}.${numbers[2]}`;
    }
    if (numbers && numbers.length >= 2) {
      return `${numbers[0]}.${numbers[1]}.0`;
    }
    if (numbers && numbers.length === 1) {
      return `${numbers[0]}.0.0`;
    }
    return null;
  }
  async fetchReleaseFile(release, fileName, headers) {
    try {
      const asset = release.assets.find((a) => a.name === fileName);
      if (!asset) {
        console.log(`File ${fileName} not found in release assets`);
        return null;
      }
      const response = await (0, import_obsidian7.requestUrl)({
        url: asset.url,
        headers: {
          ...headers,
          "Accept": "application/octet-stream"
        }
      });
      const text = response.text;
      if (text === "Not Found" || text === `{"error":"Not Found"}`) {
        console.log(`Failed to download ${fileName}: Not found`);
        return null;
      }
      return text;
    } catch (error) {
      console.error(`Error fetching ${fileName}:`, error);
      new import_obsidian7.Notice(`Error fetching ${fileName}: ${error.message}`);
      return null;
    }
  }
  async getReleaseFiles(repositoryPath, manifest) {
    try {
      const headers = {
        "Accept": "application/vnd.github.v3+json"
      };
      const release = await this.getRelease(repositoryPath, headers);
      if (!release) {
        return null;
      }
      const mainJs = await this.fetchReleaseFile(release, "main.js", headers);
      if (!mainJs) {
        console.error("Required main.js file not found in release");
        return null;
      }
      const manifestFile = await this.fetchReleaseFile(release, "manifest.json", headers);
      if (!manifestFile) {
        console.error("Required manifest.json file not found in release");
        return null;
      }
      const styles = await this.fetchReleaseFile(release, "styles.css", headers);
      return {
        mainJs,
        manifest: manifestFile,
        styles
      };
    } catch (error) {
      console.error("Error getting release files:", error);
      if (error.status === 403 || error.status === 401) {
        new import_obsidian7.Notice(`Failed to get release files: ${error.message}`);
      }
      return null;
    }
  }
  async writePluginFiles(pluginId, files) {
    const pluginDir = `${this.plugin.app.vault.configDir}/plugins/${pluginId}/`;
    const { adapter } = this.plugin.app.vault;
    if (!await adapter.exists(pluginDir)) {
      await adapter.mkdir(pluginDir);
    }
    if (files.mainJs) {
      await adapter.write(`${pluginDir}main.js`, files.mainJs);
    }
    if (files.manifest) {
      await adapter.write(`${pluginDir}manifest.json`, files.manifest);
    }
    if (files.styles) {
      await adapter.write(`${pluginDir}styles.css`, files.styles);
    }
  }
  async enablePlugin(pluginId) {
    try {
      const app = this.plugin.app;
      await app.plugins.loadManifests();
      await app.plugins.enablePlugin(pluginId);
      await new Promise((resolve) => setTimeout(resolve, 200));
      await app.plugins.loadManifests();
      if (this.plugin.settingTab) {
        await this.plugin.settingTab.checkDependencies();
        if (this.plugin.settingTab.containerEl.isShown()) {
          await this.plugin.settingTab.display();
        }
      }
    } catch (error) {
      console.error("Error enabling plugin:", error);
      new import_obsidian7.Notice(`Failed to enable plugin: ${error.message}`);
      throw error;
    }
  }
  async uninstallPlugin(pluginId) {
    try {
      const app = this.plugin.app;
      const extApp = app;
      const manifest = extApp.plugins.manifests[pluginId];
      if (!manifest) {
        new import_obsidian7.Notice(`Plugin ${pluginId} not found`);
        return false;
      }
      const pluginDir = `${app.vault.configDir}/plugins/${pluginId}/`;
      const { adapter } = app.vault;
      if (!await adapter.exists(pluginDir)) {
        new import_obsidian7.Notice(`Plugin directory not found: ${pluginId}`);
        return false;
      }
      await extApp.plugins.loadManifests();
      if (extApp.plugins.plugins[pluginId]) {
        await extApp.plugins.disablePlugin(pluginId);
        await new Promise((resolve) => setTimeout(resolve, 500));
      }
      try {
        const stylesPath = `${pluginDir}styles.css`;
        if (await adapter.exists(stylesPath)) {
          await adapter.remove(stylesPath);
          await new Promise((resolve) => setTimeout(resolve, 100));
        }
        const mainPath = `${pluginDir}main.js`;
        if (await adapter.exists(mainPath)) {
          await adapter.remove(mainPath);
          await new Promise((resolve) => setTimeout(resolve, 100));
        }
        const manifestPath = `${pluginDir}manifest.json`;
        if (await adapter.exists(manifestPath)) {
          await adapter.remove(manifestPath);
          await new Promise((resolve) => setTimeout(resolve, 300));
        }
        if (await adapter.exists(pluginDir)) {
          await adapter.rmdir(pluginDir, true);
          await new Promise((resolve) => setTimeout(resolve, 200));
        }
        await extApp.plugins.loadManifests();
        if (this.plugin.settingTab) {
          await this.plugin.settingTab.checkDependencies();
          if (this.plugin.settingTab.containerEl.isShown()) {
            await this.plugin.settingTab.display();
          }
        }
      } catch (error) {
        console.error("Error removing plugin files:", error);
        await extApp.plugins.loadManifests();
        throw error;
      }
      new import_obsidian7.Notice(`Plugin ${manifest.name} has been uninstalled`);
      return true;
    } catch (error) {
      console.error("Error uninstalling plugin:", error);
      new import_obsidian7.Notice(`Failed to uninstall plugin: ${error.message}`);
      return false;
    }
  }
  async installPlugin(name, desc, repo, pluginId) {
    try {
      const app = this.plugin.app;
      const pluginDir = `${app.vault.configDir}/plugins/${pluginId}/`;
      const { adapter } = app.vault;
      if (await adapter.exists(pluginDir)) {
        new import_obsidian7.Notice(`Plugin ${name} is already installed`);
        return false;
      }
      try {
        await adapter.mkdir(pluginDir);
        await new Promise((resolve) => setTimeout(resolve, 200));
      } catch (error) {
        console.error("Error creating plugin directory:", error);
        new import_obsidian7.Notice(`Failed to create plugin directory: ${error.message}`);
        return false;
      }
      if (!await adapter.exists(pluginDir)) {
        new import_obsidian7.Notice("Failed to create plugin directory");
        return false;
      }
      try {
        const manifestJson = {
          id: pluginId,
          name,
          version: "1.0.0",
          minAppVersion: "0.15.0",
          description: desc,
          author: "Virtual Footer",
          authorUrl: repo,
          isDesktopOnly: false
        };
        await adapter.write(
          `${pluginDir}manifest.json`,
          JSON.stringify(manifestJson, null, 2)
        );
        await new Promise((resolve) => setTimeout(resolve, 200));
      } catch (error) {
        console.error("Error writing manifest:", error);
        await adapter.rmdir(pluginDir, true);
        throw error;
      }
      try {
        const mainJsContent = await this.fetchGithubFile(repo, "main.js");
        await adapter.write(`${pluginDir}main.js`, mainJsContent);
        await new Promise((resolve) => setTimeout(resolve, 200));
      } catch (error) {
        console.error("Error writing main.js:", error);
        await adapter.rmdir(pluginDir, true);
        throw error;
      }
      try {
        const cssContent = await this.fetchGithubFile(repo, "styles.css");
        if (cssContent) {
          await adapter.write(`${pluginDir}styles.css`, cssContent);
          await new Promise((resolve) => setTimeout(resolve, 200));
        }
      } catch (error) {
        console.log("Note: styles.css not found or failed to download");
      }
      const mainJsExists = await adapter.exists(`${pluginDir}main.js`);
      const manifestExists = await adapter.exists(`${pluginDir}manifest.json`);
      if (!mainJsExists || !manifestExists) {
        await adapter.rmdir(pluginDir, true);
        new import_obsidian7.Notice("Failed to verify plugin files after installation");
        return false;
      }
      await app.plugins.loadManifests();
      new import_obsidian7.Notice(`Plugin ${name} has been installed`);
      return true;
    } catch (error) {
      console.error("Error installing plugin:", error);
      new import_obsidian7.Notice(`Failed to install plugin: ${error.message}`);
      return false;
    }
  }
  async fetchGithubFile(repo, filename) {
    try {
      const response = await fetch(`${repo}/raw/master/${filename}`);
      if (!response.ok) {
        throw new Error(`Failed to fetch ${filename}: ${response.statusText}`);
      }
      return await response.text();
    } catch (error) {
      console.error(`Error fetching ${filename}:`, error);
      throw error;
    }
  }
  compareVersions(version1, version2) {
    if (version1 === null && version2 === null)
      return 0;
    if (version1 === null)
      return -1;
    if (version2 === null)
      return 1;
    const v1 = this.coerceSemver(version1);
    const v2 = this.coerceSemver(version2);
    if (!v1 && !v2)
      return 0;
    if (!v1)
      return -1;
    if (!v2)
      return 1;
    const v1Parts = v1.split(".").map(Number);
    const v2Parts = v2.split(".").map(Number);
    for (let i = 0; i < 3; i++) {
      if (v2Parts[i] > v1Parts[i])
        return -1;
      if (v2Parts[i] < v1Parts[i])
        return 1;
    }
    return 0;
  }
};

// src/core/ContentRenderer.ts
var import_obsidian8 = require("obsidian");

// src/constants/dom.ts
var CSS_DYNAMIC_CONTENT_ELEMENT = "jots-dynamic-content-element";
var CSS_HEADER_GROUP_ELEMENT = "jots-header-group";
var CSS_FOOTER_GROUP_ELEMENT = "jots-footer-group";
var CSS_HEADER_RENDERED_CONTENT = "jots-header-rendered-content";
var CSS_FOOTER_RENDERED_CONTENT = "jots-footer-rendered-content";
var CSS_HEADER_CONTAINER = "jots-header-container";
var CSS_FOOTER_CONTAINER = "jots-footer-container";
var CSS_REMOVE_FLEX = "jots-remove-flex";
var SELECTOR_PREVIEW_HEADER_AREA = ".markdown-reading-view .markdown-preview-view .mod-header";
var SELECTOR_PREVIEW_FOOTER_AREA = ".markdown-reading-view .markdown-preview-view .mod-footer";

// src/core/ContentRenderer.ts
var ContentRenderer = class {
  constructor(plugin, leaf) {
    this.plugin = plugin;
    this.leaf = leaf;
    this.lastHeaderContent = null;
    this.lastFooterContent = null;
  }
  async createHeaderContent(content) {
    const headerGroup = this.createContentGroup(CSS_HEADER_GROUP_ELEMENT);
    const renderedContent = await this.renderMarkdown(content);
    renderedContent.classList.add(CSS_HEADER_RENDERED_CONTENT);
    headerGroup.appendChild(renderedContent);
    return headerGroup;
  }
  async createFooterContent(content) {
    const footerGroup = this.createContentGroup(CSS_FOOTER_GROUP_ELEMENT);
    const renderedContent = await this.renderMarkdown(content);
    renderedContent.classList.add(CSS_FOOTER_RENDERED_CONTENT);
    footerGroup.appendChild(renderedContent);
    return footerGroup;
  }
  createContentGroup(className) {
    const group = document.createElement("div");
    group.classList.add(CSS_DYNAMIC_CONTENT_ELEMENT, className);
    return group;
  }
  async renderMarkdown(content) {
    var _a;
    const container = document.createElement("div");
    const view = this.leaf.view;
    await import_obsidian8.MarkdownRenderer.renderMarkdown(
      content,
      container,
      ((_a = view.file) == null ? void 0 : _a.path) || "",
      view
    );
    container.addEventListener("click", (event) => {
      var _a2;
      const target = event.target;
      if (target.matches("a.internal-link")) {
        event.preventDefault();
        const href = target.getAttribute("href");
        if (href) {
          this.plugin.app.workspace.openLinkText(
            decodeURIComponent(href),
            ((_a2 = view.file) == null ? void 0 : _a2.path) || ""
          );
        }
      }
    });
    return container;
  }
  injectContent(headerContent, footerContent) {
    this.lastHeaderContent = headerContent;
    this.lastFooterContent = footerContent;
    const view = this.leaf.view;
    const isPreviewMode = view.getMode() === "preview";
    if (isPreviewMode) {
      this.injectPreviewContent(headerContent, footerContent);
    } else {
      this.injectSourceContent(headerContent, footerContent);
    }
  }
  injectPreviewContent(headerContent, footerContent) {
    const container = this.leaf.view.containerEl;
    if (headerContent) {
      const headerArea = container.querySelector(SELECTOR_PREVIEW_HEADER_AREA);
      if (headerArea) {
        headerArea.appendChild(headerContent);
      }
    }
    if (footerContent) {
      const footerArea = container.querySelector(SELECTOR_PREVIEW_FOOTER_AREA);
      if (footerArea) {
        footerArea.appendChild(footerContent);
      }
    }
  }
  injectSourceContent(headerContent, footerContent) {
    const view = this.leaf.view;
    const editor = view.editor;
    const container = this.leaf.view.containerEl;
    const cmContent = container.querySelector(".cm-content");
    if (!cmContent)
      return;
    const cmSizer = cmContent.parentElement;
    if (!cmSizer)
      return;
    this.cleanup();
    if (headerContent) {
      const headerContainer = document.createElement("div");
      headerContainer.className = CSS_HEADER_CONTAINER;
      headerContainer.appendChild(headerContent);
      cmSizer.insertBefore(headerContainer, cmContent);
    }
    if (footerContent) {
      const footerContainer = document.createElement("div");
      footerContainer.className = CSS_FOOTER_CONTAINER;
      footerContainer.appendChild(footerContent);
      cmSizer.appendChild(footerContainer);
    }
    const cmContentContainer = container.querySelector(".cm-contentContainer");
    if (cmContentContainer) {
      cmContentContainer.classList.add(CSS_REMOVE_FLEX);
    }
  }
  cleanup() {
    const container = this.leaf.view.containerEl;
    const elements = container.querySelectorAll(
      `.${CSS_HEADER_CONTAINER}, .${CSS_FOOTER_CONTAINER}`
    );
    elements.forEach((el) => el.remove());
    const cmContentContainer = container.querySelector(".cm-contentContainer");
    if (cmContentContainer) {
      cmContentContainer.classList.remove(CSS_REMOVE_FLEX);
    }
  }
  getLastHeaderContent() {
    return this.lastHeaderContent;
  }
  getLastFooterContent() {
    return this.lastFooterContent;
  }
};

// src/core/RuleProcessor.ts
var RuleProcessor = class {
  constructor(settings) {
    this.settings = settings;
  }
  getApplicableRules(file) {
    const rules = this.settings.rules || [];
    return rules.filter((rule) => {
      if (!rule.enabled)
        return false;
      if (!rule.path)
        return false;
      const pattern = rule.path.toLowerCase();
      const filePath = file.path.toLowerCase();
      if (pattern.startsWith("/") && pattern.endsWith("/")) {
        try {
          const regex = new RegExp(pattern.slice(1, -1));
          return regex.test(filePath);
        } catch (e) {
          return false;
        }
      }
      return filePath.includes(pattern);
    });
  }
  getRuleContent(rule, position) {
    return position === "header" ? rule.renderLocation === "header" /* Header */ ? rule.footerText || "" : "" : rule.renderLocation === "footer" /* Footer */ ? rule.footerText || "" : "";
  }
};

// src/commands/addJots.ts
var import_obsidian9 = require("obsidian");
async function addJotsToJournal(plugin, file) {
  const command = new AddJotsCommand(plugin);
  return command.processFile(file);
}
var AddJotsCommand = class {
  constructor(plugin) {
    this.id = "add-jots-to-journals";
    this.name = "Add JOTS to Journals";
    this.plugin = plugin;
  }
  createCalloutString(format) {
    const { sectionName } = this.plugin.settings;
    let callout = `> [!${sectionName.toLowerCase()}]`;
    switch (format) {
      case "Foldable-Open":
        callout += "+";
        break;
      case "Foldable-Closed":
        callout += "-";
        break;
      case "Plain":
      default:
        break;
    }
    return callout;
  }
  extractTimeFromTask(taskLine) {
    const timeMatch = taskLine.match(/\(time::\s*(\d{1,2}:\d{2})\)/);
    return timeMatch ? timeMatch[1] : void 0;
  }
  getTaskLetter(taskLine) {
    const match = taskLine.match(/^>\s*-\s*\[([A-Za-z])\]/);
    return match ? match[1].toUpperCase() : void 0;
  }
  sortTasks(tasks) {
    const withTime = tasks.filter((t) => t.time !== void 0);
    const withoutTime = tasks.filter((t) => t.time === void 0);
    withTime.sort((a, b) => {
      if (!a.time || !b.time)
        return 0;
      const [hoursA, minutesA] = a.time.split(":").map(Number);
      const [hoursB, minutesB] = b.time.split(":").map(Number);
      const totalMinutesA = hoursA * 60 + minutesA;
      const totalMinutesB = hoursB * 60 + minutesB;
      return totalMinutesA - totalMinutesB;
    });
    const tasksByLetter = {};
    withoutTime.forEach((task) => {
      const letter = this.getTaskLetter(task.line);
      if (letter) {
        if (!tasksByLetter[letter]) {
          tasksByLetter[letter] = [];
        }
        tasksByLetter[letter].push(task);
      }
    });
    const orderedNonTimesTasks = [];
    this.plugin.settings.taskLetters.forEach((letter) => {
      if (tasksByLetter[letter]) {
        orderedNonTimesTasks.push(...tasksByLetter[letter]);
      }
    });
    return [...withTime, ...orderedNonTimesTasks];
  }
  hasExistingCallout(content) {
    const { sectionName } = this.plugin.settings;
    const calloutPattern = new RegExp(`^> \\[!${sectionName.toLowerCase()}\\](?:[+\\-]|\\s|$)`, "m");
    return calloutPattern.test(content);
  }
  findExistingCalloutIndex(lines) {
    const { sectionName } = this.plugin.settings;
    const calloutPattern = new RegExp(`^> \\[!${sectionName.toLowerCase()}\\](?:[+\\-]|\\s|$)`);
    return lines.findIndex((line) => calloutPattern.test(line));
  }
  isTaskInCallout(lines, taskLineIndex) {
    let nearestCalloutStart = -1;
    let nearestCalloutEnd = -1;
    for (let i = taskLineIndex - 1; i >= 0; i--) {
      const line = lines[i].trim();
      if (line.match(new RegExp(`^> \\[!${this.plugin.settings.sectionName.toLowerCase()}\\](?:[+\\-]|\\s|$)`))) {
        nearestCalloutStart = i;
        break;
      }
    }
    if (nearestCalloutStart !== -1) {
      for (let i = nearestCalloutStart + 1; i < lines.length; i++) {
        if (!lines[i].trimStart().startsWith(">")) {
          nearestCalloutEnd = i - 1;
          break;
        }
        if (i === lines.length - 1) {
          nearestCalloutEnd = i;
        }
      }
      return taskLineIndex > nearestCalloutStart && taskLineIndex <= nearestCalloutEnd;
    }
    return false;
  }
  getCalloutFormatFromLine(line) {
    const { sectionName } = this.plugin.settings;
    if (line.match(new RegExp(`^> \\[!${sectionName.toLowerCase()}\\]\\+`))) {
      return "Foldable-Open";
    } else if (line.match(new RegExp(`^> \\[!${sectionName.toLowerCase()}\\]\\-`))) {
      return "Foldable-Closed";
    }
    return "Plain";
  }
  updateCalloutFormat(lines, calloutIndex) {
    const currentLine = lines[calloutIndex];
    const currentFormat = this.getCalloutFormatFromLine(currentLine);
    const desiredFormat = this.plugin.settings.sectionFormat;
    if (currentFormat !== desiredFormat) {
      const { sectionName } = this.plugin.settings;
      const baseCallout = `> [!${sectionName.toLowerCase()}]`;
      let newCallout = baseCallout;
      switch (desiredFormat) {
        case "Foldable-Open":
          newCallout += "+";
          break;
        case "Foldable-Closed":
          newCallout += "-";
          break;
      }
      lines[calloutIndex] = newCallout;
      return true;
    }
    return false;
  }
  findExistingCalloutSections(lines) {
    const sections = [];
    const { sectionName } = this.plugin.settings;
    const calloutPattern = new RegExp(`^> \\[!${sectionName.toLowerCase()}\\](?:[+\\-]|\\s|$)`);
    for (let i = 0; i < lines.length; i++) {
      if (calloutPattern.test(lines[i].trim())) {
        let endIndex = i;
        for (let j = i + 1; j < lines.length; j++) {
          if (!lines[j].trimStart().startsWith(">")) {
            endIndex = j - 1;
            break;
          }
          if (j === lines.length - 1) {
            endIndex = j;
          }
        }
        sections.push({ startIndex: i, endIndex });
        i = endIndex;
      }
    }
    return sections;
  }
  findJotsSection(lines) {
    const { sectionName } = this.plugin.settings;
    const headerPattern = new RegExp(`^> \\[!${sectionName.toLowerCase()}\\](?:[+\\-]|\\s|$)`);
    const headerIndex = lines.findIndex((line) => headerPattern.test(line));
    if (headerIndex === -1)
      return null;
    let endIndex = headerIndex;
    const items = [];
    for (let i = headerIndex + 1; i < lines.length; i++) {
      const line = lines[i].trim();
      if (!line.startsWith("> -")) {
        endIndex = i - 1;
        break;
      }
      if (i === lines.length - 1) {
        endIndex = i;
      }
      const taskMatch = line.match(/^>\s*-\s*\[([A-Za-z])\]/);
      if (taskMatch) {
        items.push({
          line,
          index: i,
          time: this.extractTimeFromTask(line)
        });
      }
    }
    return {
      startIndex: headerIndex,
      endIndex,
      items
    };
  }
  findMatchingTasks(lines) {
    const tasks = [];
    const seenTasks = /* @__PURE__ */ new Set();
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      const taskMatch = line.match(/^(>?\s*)?-\s*\[([A-Za-z])\]/);
      if (taskMatch && this.plugin.settings.taskLetters.includes(taskMatch[2].toUpperCase())) {
        const normalizedTask = line.replace(/^>\s*/, "").trim();
        const formattedTask = `> ${normalizedTask}`;
        if (!seenTasks.has(normalizedTask)) {
          tasks.push({
            line: formattedTask,
            index: i,
            time: this.extractTimeFromTask(line)
          });
          seenTasks.add(normalizedTask);
        }
      }
    }
    return tasks;
  }
  removeMatchingTasks(lines, tasks) {
    var _a;
    const taskStrings = new Set(tasks.map(
      (task) => task.line.replace(/^>\s*/, "").trim()
    ));
    for (let i = lines.length - 1; i >= 0; i--) {
      const normalizedLine = lines[i].trim().replace(/^>\s*/, "").trim();
      if (taskStrings.has(normalizedLine)) {
        lines.splice(i, 1);
        if (i > 0 && lines[i - 1].trim() === "") {
          lines.splice(i - 1, 1);
          i--;
        }
        if (i < lines.length && ((_a = lines[i]) == null ? void 0 : _a.trim()) === "") {
          lines.splice(i, 1);
        }
      }
    }
  }
  cleanupEmptyLines(lines) {
    for (let i = lines.length - 1; i > 0; i--) {
      if (lines[i].trim() === "" && lines[i - 1].trim() === "") {
        lines.splice(i, 1);
      }
    }
    while (lines.length > 0 && lines[lines.length - 1].trim() === "") {
      lines.pop();
    }
  }
  async processFileContent(content) {
    const yamlRegex = /^---\n([\s\S]*?)\n---/;
    const yamlMatch = content.match(yamlRegex);
    const yamlFrontmatter = yamlMatch ? yamlMatch[0] : null;
    let contentWithoutYaml = yamlMatch ? content.slice(yamlMatch[0].length).trim() : content.trim();
    const lines = contentWithoutYaml.split("\n");
    const allTasks = [];
    let changed = false;
    const existingSection = this.findJotsSection(lines);
    if (existingSection) {
      allTasks.push(...existingSection.items);
      lines.splice(existingSection.startIndex, existingSection.endIndex - existingSection.startIndex + 1);
      changed = true;
    }
    const matchingTasks = this.findMatchingTasks(lines);
    if (matchingTasks.length > 0) {
      allTasks.push(...matchingTasks);
      this.removeMatchingTasks(lines, matchingTasks);
      changed = true;
    }
    if (!changed)
      return null;
    this.cleanupEmptyLines(lines);
    const finalLines = [];
    if (yamlFrontmatter) {
      finalLines.push(yamlFrontmatter, "");
    }
    finalLines.push(...lines);
    if (allTasks.length > 0) {
      if (finalLines.length > 0 && finalLines[finalLines.length - 1].trim() !== "") {
        finalLines.push("");
      }
      finalLines.push(this.createCalloutString(this.plugin.settings.sectionFormat));
      finalLines.push(...this.sortTasks(allTasks).map((task) => task.line));
    }
    return finalLines.join("\n");
  }
  async processActiveFile() {
    const activeView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian9.MarkdownView);
    if (!activeView)
      return;
    const content = activeView.editor.getValue();
    const newContent = await this.processFileContent(content);
    if (newContent !== null) {
      activeView.editor.setValue(newContent);
    }
  }
  async processFile(file) {
    const content = await this.plugin.app.vault.read(file);
    const newContent = await this.processFileContent(content);
    if (newContent !== null) {
      await this.plugin.app.vault.modify(file, newContent);
      return true;
    }
    return false;
  }
  async callback() {
    await this.processActiveFile();
  }
};

// src/api/JotsApi.ts
var JotsApi = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  /**
   * Check if JOTS Assistant is available
   * @returns boolean indicating if JOTS Assistant is available
   */
  static isAvailable() {
    var _a;
    return !!((_a = window.JotsAssistant) == null ? void 0 : _a.api);
  }
  /**
   * Get the JOTS Assistant API if it's available
   * @returns The JOTS Assistant API instance if available, undefined otherwise
   */
  static getApi() {
    var _a;
    return (_a = window.JotsAssistant) == null ? void 0 : _a.api;
  }
  /**
   * Add JOTS entries to a specific journal
   * @param journalName The name of the journal to add JOTS to
   * @returns Promise that resolves when the operation is complete
   */
  async addJotsToJournal(journalName) {
    console.debug("JOTS Assistant API: addJotsToJournal called with:", journalName);
    console.debug("JOTS Assistant API: Settings:", {
      rootFolder: this.plugin.settings.journalRootFolder,
      folderPattern: this.plugin.settings.journalFolderPattern,
      filePattern: this.plugin.settings.journalFilePattern
    });
    const files = this.plugin.app.vault.getMarkdownFiles();
    console.debug("JOTS Assistant API: Looking for files with basename:", journalName);
    console.debug("JOTS Assistant API: Available files:", files.map((f) => ({
      path: f.path,
      basename: f.basename,
      matches: f.basename === journalName
    })));
    const journalFile = files.find((file) => file.basename === journalName);
    console.debug("JOTS Assistant API: Found journal file:", journalFile);
    if (!journalFile) {
      console.error("JOTS Assistant API: Journal not found:", journalName);
      throw new Error(`Journal "${journalName}" not found`);
    }
    console.debug("JOTS Assistant API: Processing journal file...");
    await addJotsToJournal(this.plugin, journalFile);
  }
  /**
   * Get journal path information for finding journal files
   * @returns Object containing journal path settings
   */
  getJournalPathInfo() {
    return {
      rootFolder: this.plugin.settings.journalRootFolder,
      folderPattern: this.plugin.settings.journalFolderPattern,
      filePattern: this.plugin.settings.journalFilePattern
    };
  }
  /**
   * Get the plugin's settings
   * @returns The current plugin settings
   */
  getSettings() {
    return this.plugin.settings;
  }
};

// src/main.ts
var JotsPlugin = class extends import_obsidian10.Plugin {
  constructor(app, manifest) {
    super(app, manifest);
    this.contentRenderers = /* @__PURE__ */ new WeakMap();
    this.fileStates = /* @__PURE__ */ new Map();
    this.initialLayoutReadyProcessed = false;
    this.instanceId = Math.random().toString(36).substring(2, 15);
    console.log("JOTS BASIC: Constructor called");
  }
  debugLog(message, data) {
    var _a;
    const timestamp = new Date().toISOString().split("T")[1];
    const stack = (_a = new Error().stack) == null ? void 0 : _a.split("\n").slice(2).join("\n");
    const logMessage = `[JOTS-${this.instanceId} ${timestamp}] ${message} ${JSON.stringify({
      ...data,
      _debug: {
        stack,
        pluginId: this.manifest.id,
        instanceId: this.instanceId
      }
    }, null, 2)}`;
    console.log(logMessage);
  }
  async onload() {
    console.log("JOTS BASIC: Plugin loading");
    await this.loadSettings();
    this.pluginManager = new PluginManager(this);
    this.ruleProcessor = new RuleProcessor(this.settings);
    this.api = new JotsApi(this);
    this.debugLog("Initializing API");
    window.JotsAssistant = {
      api: this.api
    };
    this.styleEl = document.createElement("style");
    this.styleEl.setAttribute("type", "text/css");
    document.head.appendChild(this.styleEl);
    this.updateStyles();
    if (this.settings.updateAtStartup) {
      this.checkForUpdates();
    }
    const self = this;
    const originalInjectContent = ContentRenderer.prototype.injectContent;
    ContentRenderer.prototype.injectContent = function(...args) {
      var _a, _b;
      console.log("JOTS BASIC: injectContent called", (_b = (_a = this.leaf.view) == null ? void 0 : _a.file) == null ? void 0 : _b.path);
      return originalInjectContent.apply(this, args);
    };
    const observer = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        if (mutation.type === "childList" && mutation.addedNodes.length > 0) {
          const headers = Array.from(mutation.addedNodes).filter((node) => node instanceof HTMLElement && node.classList.contains("jots-header"));
          const footers = Array.from(mutation.addedNodes).filter((node) => node instanceof HTMLElement && node.classList.contains("jots-footer"));
          if (headers.length > 0 || footers.length > 0) {
            this.debugLog("DOM mutation detected header/footer changes", {
              headers: headers.length,
              footers: footers.length,
              targetClass: mutation.target instanceof HTMLElement ? mutation.target.className : "unknown"
            });
          }
        }
      }
    });
    this.register(() => observer.disconnect());
    setTimeout(() => {
      observer.observe(document.body, {
        childList: true,
        subtree: true
      });
      this.debugLog("Started DOM observer");
    }, 1e3);
    this.addCommand({
      id: "refresh-headers-footers",
      name: "Refresh Headers and Footers",
      callback: () => {
        console.log("JOTS BASIC: Manual refresh triggered");
        const view = this.app.workspace.getActiveViewOfType(import_obsidian10.MarkdownView);
        if (view) {
          this._processView(view);
        }
      }
    });
    this.registerEvent(
      this.app.workspace.on("file-open", (file) => {
        if (!file)
          return;
        console.log("JOTS BASIC: File opened", file.path);
        const view = this.app.workspace.getActiveViewOfType(import_obsidian10.MarkdownView);
        if (view) {
          this._processView(view);
        }
      })
    );
    this.app.workspace.onLayoutReady(() => {
      if (!this.initialLayoutReadyProcessed) {
        console.log("JOTS BASIC: Initial layout ready");
        const view = this.app.workspace.getActiveViewOfType(import_obsidian10.MarkdownView);
        if (view == null ? void 0 : view.file) {
          this._processView(view);
        }
        this.initialLayoutReadyProcessed = true;
      }
    });
    console.log("JOTS BASIC: Plugin load complete");
  }
  onunload() {
    console.log("JOTS Assistant: Unloading Plugin...");
    if (this.styleEl && this.styleEl.parentNode) {
      this.styleEl.parentNode.removeChild(this.styleEl);
    }
    delete window.JotsAssistant;
    this.app.workspace.getLeavesOfType("markdown").forEach((leaf) => {
      if (leaf.view instanceof import_obsidian10.MarkdownView) {
        const renderer = this.contentRenderers.get(leaf.view);
        if (renderer) {
          renderer.cleanup();
          this.contentRenderers.delete(leaf.view);
        }
      }
    });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.ruleProcessor = new RuleProcessor(this.settings);
  }
  async saveSettings(options = {}) {
    const { refreshViews = true, refreshType = "all" } = options;
    await this.saveData(this.settings);
    this.ruleProcessor = new RuleProcessor(this.settings);
    if (!refreshViews)
      return;
    if (refreshType === "all" || refreshType === "styles") {
      this.updateStyles();
    }
    if (refreshType === "all" || refreshType === "content") {
      await this.refreshAllViews();
    }
  }
  async refreshAllViews() {
    this.app.workspace.getLeavesOfType("markdown").forEach((leaf) => {
      if (leaf.view instanceof import_obsidian10.MarkdownView) {
        this._processView(leaf.view);
      }
    });
  }
  updateStyles() {
    const iconWithColor = this.settings.sectionIcon.replace('"black"', `"${this.settings.labelColor}"`);
    this.styleEl.textContent = generateJotsIconCss(this.settings.sectionName, iconWithColor, this.settings.labelColor);
  }
  async checkForUpdates() {
    const app = this.app;
    const plugins = app.plugins;
    const pluginDir = `${app.vault.configDir}/plugins/`;
    const { adapter } = app.vault;
    const managedPlugins = ["dataview", "virtual-footer"];
    for (const pluginId of managedPlugins) {
      const pluginPath = `${pluginDir}${pluginId}/`;
      if (!await adapter.exists(pluginPath))
        continue;
      try {
        const manifest = plugins.manifests[pluginId];
        if (!(manifest == null ? void 0 : manifest.authorUrl))
          continue;
        const repoPath = manifest.authorUrl.replace("https://github.com/", "");
        const result = await this.pluginManager.addPlugin(repoPath);
        if (result) {
          new import_obsidian10.Notice(`Plugin ${manifest.name} has been updated to the latest version`);
        }
      } catch (error) {
        console.error(`Error checking updates for ${pluginId}:`, error);
      }
    }
  }
  async _processView(view) {
    if (!(view == null ? void 0 : view.file)) {
      console.log("JOTS BASIC: _processView called with invalid view");
      return;
    }
    console.log("JOTS BASIC: _processView called for", view.file.path, new Error().stack);
    const applicableRules = this.ruleProcessor.getApplicableRules(view.file);
    const existingRenderer = this.contentRenderers.get(view);
    if (existingRenderer) {
      console.log("JOTS BASIC: Cleaning up existing renderer for", view.file.path);
      existingRenderer.cleanup();
      this.contentRenderers.delete(view);
    }
    if (applicableRules.length === 0) {
      console.log("JOTS BASIC: No applicable rules for", view.file.path);
      return;
    }
    console.log("JOTS BASIC: Found", applicableRules.length, "rules for", view.file.path);
    let headerContent = "";
    let footerContent = "";
    for (const rule of applicableRules) {
      const header = this.ruleProcessor.getRuleContent(rule, "header");
      const footer = this.ruleProcessor.getRuleContent(rule, "footer");
      if (header)
        headerContent += header + "\n\n";
      if (footer)
        footerContent += footer + "\n\n";
    }
    console.log("JOTS BASIC: Creating new renderer for", view.file.path);
    const renderer = new ContentRenderer(this, view.leaf);
    this.contentRenderers.set(view, renderer);
    const headerElement = headerContent ? await renderer.createHeaderContent(headerContent.trim()) : null;
    const footerElement = footerContent ? await renderer.createFooterContent(footerContent.trim()) : null;
    console.log("JOTS BASIC: Injecting content for", view.file.path, {
      hasHeader: !!headerElement,
      hasFooter: !!footerElement
    });
    renderer.injectContent(headerElement, footerElement);
    console.log("JOTS BASIC: _processView completed for", view.file.path);
  }
};
